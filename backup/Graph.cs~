using System;
using System.Collections.Generic;
using System.Linq;

namespace PrimAlgorithm
{
  public class Graph<T>
  {
    public Dictionary<int, Node<T>> Nodes { get; } = new Dictionary<int, Node<T>>();
    public List<Edge<T>> Edges { get; } = new List<Edge<T>>();
    public bool Directed { get; }

    public Graph(bool directed = false)
    {
      Directed = directed;
    }

    int GenerateEdgeId()
    {
      Edge<T> last = Edges.LastOrDefault();
      return last != null ? last.Id + 1 : 0;
    }

    public Node<T> GetNode(int key) => 
      key < Nodes.Count ? Nodes[key] : null; // TODO: handle exception.

    public void AddNode(T value) => 
    {
      Nodes.Add(Nodes.Count, new Node<T>(Nodes.Count, value));
    }

    public void AddEdge(int source, int destination, int weight = 1)
    {
      // Create edge
      var edge = new Edge<T>(
        node1: GetNode(source),
        node2: GetNode(destination),
        weight: weight,
        id: GenerateEdgeId()
      );

      // Register edge in the corresponding list.
      Edges.Add(edge);

      // Register adjacent node in the source node (using the an edge to store the information).
      Nodes[source].Adjacents.AddLast(edge);
      if (!Directed)
        Nodes[destination].Adjacents.AddLast(edge);
    }

    // Graph exploration using DFS
    public bool HasPathDFS(int source, int destination) =>
      HasPathDFS(GetNode(source), GetNode(destination), new HashSet<int>());

    bool HasPathDFS(Node<T> source, Node<T> destination, HashSet<int> visited)
    {
      // If doesn't exist.
      if (visited.Contains(source.Id))
        return false;

      // Register visit.
      visited.Add(source.Id);

      // If it has been found, notify the match.
      if (source == destination)
        return true;

      // If there is no match, search in the source children.
      foreach (var child in source.Adjacents)
        if (HasPathDFS(child.Node2, destination, visited))
          return true;

      return false;
    }

    // Graph exploration using BFS.
    public bool HasPathBFS(int source, int destination) =>
      HasPathBFS(GetNode(source), GetNode(destination));

    bool HasPathBFS(Node<T> source, Node<T> destination)
    {
      var visited = new HashSet<int>(); // Stores the visited nodes ids.
      var nextsToVisit = new LinkedList<Node<T>>(); // Store the adjacent nodes of the current node.
      nextsToVisit.AddLast(source);

      // While there are still nodes to visit, search a match.
      while (nextsToVisit.Count != 0)
      {
        Node<T> node = nextsToVisit.First.Value;
        nextsToVisit.RemoveFirst();

        // If it found the node, notify it.
        if (node == destination)
          return true;

        // If has been visited, evaluate the next.
        if (visited.Contains(node.Id))
          continue;

        // Mark as visited the current node.
        visited.Add(node.Id);

        // Add to the list of nexts to visit the adjacents nodes of the current node.
        foreach (Edge<T> child in node.Adjacents)
          nextsToVisit.AddLast(child.Node2);
      }

      return false;
    }


    // Find shortest path using DFS.
    public List<Edge<T>> FindShortestPath(int source, int destination)
    {
      var path = new List<Edge<T>>();
      HasPathBFS2(GetNode(source), GetNode(destination), path);
      return path;
    }

    bool HasPathBFS2(Node<T> source, Node<T> destination, List<Edge<T>> path)
    {
      var nextToVisit = new Queue<Edge<T>>();
      var paths = new Edge<T>[Nodes.Count];
      int[] distances = Enumerable
        .Range(0, Nodes.Count)
        .Select(distance => Int32.MaxValue)
        .ToArray();
        
      // Register the starting node.  
      nextToVisit.Enqueue(new Edge<T>(source, source, 0, 0));

      // While there are still nodes to visit, search for a match.
      while(nextToVisit.Count != 0)
      {
        Edge<T> current = nextToVisit.Dequeue();
        int parent = current.Node1.Id;
        int adjacent = current.Node2.Id;

        // If ends the travel.
        if(current.Node1.Id == destination.Id)
          return true;

        // If has been visited, evaluate the next node.
        if(distances[adjacent] != Int32.MaxValue)
          continue;

        // Indicate the distance.
        distances[adjacent] = distances[parent] == Int32.MaxValue ? 0 : distances[parent] + 1;
        paths[adjacent] = current;

        foreach(Edge<T> edge in current.Node2.Adjacents)
          nextToVisit.Enqueue(edge);
      }

      // Trace path.
      for (int i = destination.Id; i != source.Id; i = paths[i].Node1.Id)
        path.Add(paths[i]);

      path.Reverse();

      return false;
    }

    // Dijkstra's algorithm
    public List<Edge<T>> FindPathDijkstra(int source, int destination)
    {
      var path = new List<Edge<T>>();
      HasPathBFS3(GetNode(source), GetNode(destination), path);
      return path;
    }

    bool HasPathBFS3(Node<T> source, Node<T> destination, List<Edge<T>> path)
    {
      var nextToVisit = new Queue<Edge<T>>();
      var paths = new Edge<T>[Nodes.Count];
      int[] distances = Enumerable
        .Range(0, Nodes.Count)
        .Select(distance => Int32.MaxValue)
        .ToArray();
        
      // Register the starting node.  
      nextToVisit.Enqueue(new Edge<T>(source, source, 0, 0));

      // While there are still nodes to visit, search for a match.
      while(nextToVisit.Count != 0)
      {
        Edge<T> current = nextToVisit.Dequeue();

        // If ends the travel.
        if(current.Node1.Id == destination.Id)
          return true;

        // If has been visited, evaluate the next node.
        if(distances[current.Node2.Id] != Int32.MaxValue)
          continue;

        // Indicate the distance.
        distances[current.Node2.Id] = distances[current.Node1.Id] + 1;
        paths[current.Node2.Id] = current;

        foreach(Edge<T> edge in current.Node2.Adjacents)
          nextToVisit.Enqueue(edge);
      }

      // Trace path.
      for (int i = destination.Id; i != source.Id; i = paths[i].Node1.Id)
        path.Add(paths[i]);

      path.Reverse();

      return false;
    }
  }    
}
