#include "linked_list.hpp"
#include "node.hpp"

template <typename T>
LinkedList::LinkedList<T>::LinkedList() {
  _head = NULL;
  _lenght = 0;
}

template <typename T>
LinkedList::LinkedList<T>::~LinkedList() { } 

template <typename T>
void LinkedList::LinkedList<T>::insertAfter(Node<T>* node, T* data) {
  Node<T>* newNode = new Node<T>(data, node, node->next);

  // If insert newNode after _last.
  if(node->next == NULL)
  {
    node->next = newNode;
    _last = newNode;
  }
  else
  {
    node->next->previous = newNode;
    node->next = newNode;
  }

  _lenght++;
}

template <typename T>
void LinkedList::LinkedList<T>::insertBefore(LinkedList::Node<T>* node, T* data) {
  LinkedList::Node<T>* newNode = new LinkedList::Node<T>(data, node->previous, node);

  // If insert newNode before _head.
  if(node->previous == NULL)
  {
    node->previous = newNode;
    _head = newNode;
  }
  else
  {
    node->previous->next = newNode;
    node->previous = newNode;
  }
  
  _lenght++;
}

template <typename T>
void LinkedList::LinkedList<T>::insertBeginning(T* data) {
  LinkedList::Node<T>* newNode = new LinkedList::Node<T>(data);

  if(isEmpty())
  {
    _head=  newNode;
    _last =  newNode;
    _lenght++;
  }
  else
    insertBefore(_head, data);
}

template <typename T>
void LinkedList::LinkedList<T>::insertEnd(T* data) {
  if(isEmpty())
    insertBeginning(data);
  else
    insertAfter(_last, data);
}

template <typename T>
void LinkedList::LinkedList<T>::remove(LinkedList::Node<T>* node) {
  if(node->previous == NULL)
    _head = node->next;
  else
    node->previous->next = node->next; 
  
  if(node->next == NULL)
    _last = node->previous;
  else
    node->next->previous = node->previous;

  delete node;
  _lenght--;
}

template <typename T>
LinkedList::Node<T>* LinkedList::LinkedList<T>::find(bool callback(T* data)) {
  LinkedList::Node<T>* current = _head;
  for(int i = 0; i < _lenght; i++)
  {
    if(callback(current->data))
      return current;
    
    current = current->next;
  }
}

template <typename T>
void LinkedList::LinkedList<T>::forEach(void callback(T* data)) {
  LinkedList::Node<T>* current = _head;
  for(int i = 0; i < _lenght; i++)
  {
    callback(current->data);
    current = current->next;
  }
}

template <typename T>
bool LinkedList::LinkedList<T>::isEmpty() {
  return (_head == NULL) ? true : false;
}
