import os
from abc import abstractmethod
from helpers.config_provider import ConfigProvider

from helpers.string_helper import StringHelper

class Element:
  @property
  def name(self):
    return self.__name

  @name.setter
  def name(self, value):
    self.__name = value

  @property
  def code(self):
    return self.__code

  @code.setter
  def code(self, value):
    self.__code = value

  @property
  def code_number(self):
    print('code?: ', self.code)
    return int(self.code[1:])

  @code_number.setter
  def code_number(self, value):
    self.code = f"{self.code[0]}{value}"

  @property
  def full_name(self):
    return self.code + (self.__config.separator + self.name if self.name else '')

  @property
  def underscore_fullname(self):
    return self.code + (self.__config.separator + self.underscore_name if self.underscore_name else '')

  @property
  def underscore_name(self):
    separator = self.__config.separator
    underscore_words = ""
    words = self.name.split()

    if len(words) > 1:
      for i in range(0, len(words)):
        word = words[i]
        if self.is_roman_number(word):
          underscore_words += word if i == 0 else separator + word
        else:
          underscore_words += word.lower() if i == 0 else separator + word.lower()
      return underscore_words
    else: # If it's in fact a very probably underscored name
      return words[0] if len(words) else ''

  @property
  def capitalized_name(self):
    capitalized_words = ""

    # Evaluate what type of split to do and aply it.
    space_parts = self.name.split()
    underscore_parts = self.name.split(self.__config.separator)

    words = space_parts if len(space_parts) > len(underscore_parts) else underscore_parts

    for i in range(0, len(words)):
      word = words[i]
      if self.is_roman_number(word):
        capitalized_words += word if i == 0 else ' ' + word
      else:
        capitalized_words += word.capitalize() if i == 0 else ' ' + word.capitalize()

    return capitalized_words

  def __init__(self, code, name):
    self.__code = code
    self.__name = name
    self.__config = ConfigProvider.instance()

    print('self.__code', self.__code)
    print('self.__name', self.__name)
    print('self.__config', self.__config)

  @classmethod
  def from_full_name(cls, full_name):
    config = ConfigProvider.instance()
    name_parts = full_name.split(config.separator)
    print('name_parts: ', name_parts)
    element_code = name_parts[0]
    element_name = name_parts[1] if len(name_parts) > 1 else ''

    return cls(element_code, element_name)

  @staticmethod
  def generate_default_name(name, identifier_name):
    separator = ConfigProvider.instance().separator
    return name if name != None else ('new' + separator + identifier_name)

  # TODO: Delete this method after finishing all corrections in this class.
  @staticmethod
  def extract_last_number(elements_directory, identifier, all_elements):
    last_element_directory = all_elements[-1] if all_elements else os.path.join(elements_directory, f'{identifier}0')
    last_element_name = os.path.basename(last_element_directory)
    last_element_number = StringHelper.extract_number(last_element_name)

    return last_element_number

  def is_roman_number(self, word):
    # List of the first ten roman numbers
    numbers = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X']

    if (word in numbers) or (word[:-1] in numbers and word[len(word) - 1] == ')' and len(word) > 1):
      return True
    else:
      return False
